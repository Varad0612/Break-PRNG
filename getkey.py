# My plaintext assumption for the first 4 bytes
s1 = "%%%%"
l1 = []
x1 = []

# Read input from the encrypted file
# and append the hex value of each byte to inp[]
inp = []
with open("hw2.tex.enc", "rb") as f:
	char = (f.read(1)).encode("hex")
	while char != "":
		inp.append(int(char, 16))
		char = f.read(1).encode("hex")
f.close()

# Stores the first 4 bytes of the ciphertext
beg = []
for i in range(4):
	beg.append(inp[i])

# Get the ascii value of "%%%%"
for i in range(len(s1)):
	l1.append(ord(s1[i]))

# XOR plaintext with ciphertext to get the 
# first 4 bytes of the keystream
for i in range(len(l1)):
	x1.append(l1[i]^beg[i])

# Get the integer value represented by the
# 4 bytes
def proc(ls):
	s = ""
	for n in ls:
		b = bin(n)[2:]
		if(len(b) < 8):
			b = "0"*(8-len(b)) + b
		s = b + s   
	return int(s, 2)


def seed(s):
	s = s -12345
	s = (s * 1857678181)%2147483648
	return s

# Get the first integer generated by rand
key_0 = proc(x1)

# Append the MSB cleared out by 0x7fffffff
# Note: key_0 was only 31 bits long
bin_repr_key_0 = bin(key_0)[2:]
cnd1 = int("0"+bin_repr_key_0,2)
cnd2 = int("1"+bin_repr_key_0,2)

# Get the seed
# Use this seed value in decrypt.c
s1 = seed(cnd1)
s2 = seed(cnd2)
print "Seed: " + str(s1)
print "Seed: " + str(s2)